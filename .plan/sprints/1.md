# Sprint 1 â€” Database & Persistence (detailed)

Goal: implement the data layer and repository methods so endpoints and UI can
rely on a stable persistence API.

Tasks

- Schema & Migrations

  - Use Drizzle ORM to declare the `contacts` table per `.plan/specs/data-model.md`.
  - Keep column names snake_case for DB (`first_name`, `last_name`, etc.) and map
    to camelCase in TypeScript repository layer.
  - Add a lightweight migration or seed script that can create the DB schema in a
    temp file for CI/local dev.

- Repository

  - Implement and export the following functions from `backend/db/repos/contacts.ts`:
    - `createContact(payload: ContactCreate): Promise<Contact>`
    - `listContacts(opts?: { q?: string; verified?: boolean }): Promise<Contact[]>`
    - `getContactById(id: string): Promise<Contact | null>`
    - `verifyContact(id: string): Promise<Contact | null>`
    - `deleteContact(id: string): Promise<void>`
  - Ensure functions return types derived from Drizzle's `typeof table.$inferSelect` or `typeof table.$inferInsert`.

- Tests
  - Unit tests for each repo function using Deno's test runner.
  - Use an in-memory or temp sqlite file for tests. Ensure cleanup between tests.

Acceptance criteria

- Repos are strongly typed and pass the unit tests.
- The DB file/URL is configurable via env (e.g., `DB_FILE_NAME`), and tests override
  it to use temporary storage.
- All changes are covered by small, reviewable PRs (one PR per repo + tests).

Notes

- Keep SQL small and portable. Prefer sqlite-core for local dev and allow driver
  swap (libSQL/Turso) via Drizzle config.
- Use `crypto.randomUUID()` for IDs in repos; map to Zod `id` schema.
